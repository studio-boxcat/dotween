using System;
using JetBrains.Annotations;
using Sirenix.OdinInspector;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.UI;
using Object = UnityEngine.Object;

#pragma warning disable 1591
namespace DG.Tweening
{
    public enum DOTweenAnimationType : byte
    {
        None = 0,
        LocalMove = 2,
        LocalRotateZ = 4,
        Scale = 5,
        Color = 6,
        Fade = 7,
        PunchPosition = 9,
        PunchRotation = 10,
        PunchScale = 11,
        ShakePosition = 12,
        ShakeRotation = 13,
        ShakeScale = 14,
        UIAnchors = 22,
    }

    /// <summary>
    /// Attach this to a GameObject to create a tween
    /// </summary>
    [AddComponentMenu("DOTween/DOTween Animation")]
    public sealed class DOTweenAnimation : MonoBehaviour
#if UNITY_EDITOR
        , ISelfValidator
#endif
    {
        [NonSerialized]
        public Tweener tween;

        public float delay;
        public float duration = 1;
        public Ease easeType = Ease.OutQuad;
        public AnimationCurve easeCurve = new(new Keyframe(0, 0), new Keyframe(1, 1));
        public LoopType loopType = LoopType.Restart;
        public int loops = 1;
        public bool isRelative;
        public bool isFrom;
        public bool autoKill = true;
        public bool autoGenerate = true; // If TRUE automatically creates the tween at startup

        [Required, ChildGameObjectsOnly]
        public Component target;
        public DOTweenAnimationType animationType;
        public bool autoPlay = true;

        public float endValueFloat;
        public Vector3 endValueV3;
        public Color endValueColor = new Color(1, 1, 1, 1);

        public bool optionalBool0, optionalBool1;
        public float optionalFloat0;
        public int optionalInt0;

        bool _tweenAutoGenerationCalled; // TRUE after the tweens have been autoGenerated

        #region Unity Methods

        void Awake()
        {
            if (!autoGenerate) return;

            CreateTween(false, autoPlay);
            _tweenAutoGenerationCalled = true;
        }

        void Start()
        {
            if (_tweenAutoGenerationCalled || !autoGenerate) return;

            CreateTween(false, autoPlay);
            _tweenAutoGenerationCalled = true;
        }

        void OnDestroy()
        {
            if (tween != null)
            {
                if (tween.active)
                    tween.Kill();
                tween = null;
            }
        }

        // Used also by DOTweenAnimationInspector when applying runtime changes and restarting
        /// <summary>
        /// Creates the tween manually (called automatically if AutoGenerate is set in the Inspector)
        /// from its target's current value.
        /// </summary>
        /// <param name="regenerateIfExists">If TRUE and an existing tween was already created (and not killed), kills it and recreates it with the current
        /// parameters. Otherwise, if a tween already exists, does nothing.</param>
        /// <param name="andPlay">If TRUE also plays the tween, otherwise only creates it</param>
        public void CreateTween(bool regenerateIfExists = false, bool andPlay = true)
        {
            Assert.AreNotEqual(DOTweenAnimationType.None, animationType, "AnimationType is None");
            Assert.IsNotNull(target, "Target is null");

            if (tween != null)
            {
                if (tween.active)
                {
                    if (regenerateIfExists) tween.Kill();
                    else return;
                }
                tween = null;
            }

            tween = CreateTweenInstance();
            tween.OnKill(() => tween = null);
            if (andPlay is false)
                tween.Pause();
        }

        [MustUseReturnValue]
        public Tweener CreateTweenInstance()
        {
            L.I($"[DOTweenAnimation] CreateTweenInstance: {animationType} - {target}", this);

            // Create tween.
            var t = CreateTween(
                target, transform, animationType, duration,
                endValueFloat, endValueV3, endValueColor,
                optionalBool0, optionalBool1, optionalFloat0, optionalInt0);

            // Set from or relative.
            if (isFrom) t.From(isRelative);
            else t.SetRelative(isRelative);

            // Set basic tween settings.
            t.SetTarget(gameObject)
                .SetDelay(delay).SetLoops(loops, loopType).SetAutoKill(autoKill);

            // Set easeType.
            if (easeType is Ease.INTERNAL_Custom) t.SetEase(easeCurve);
            else t.SetEase(easeType);

            return t;
        }

        #endregion

        [NotNull]
        static Tweener CreateTween(
            Object target, Transform transform,
            DOTweenAnimationType animationType,
            float duration,
            float endValueFloat,
            Vector3 endValueV3,
            Color endValueColor,
            bool optionalBool0,
            bool optionalBool1,
            float optionalFloat0,
            int optionalInt0)
        {
            return animationType switch
            {
                DOTweenAnimationType.LocalMove => transform.DOLocalMove(endValueV3, duration),
                DOTweenAnimationType.LocalRotateZ => transform.DOLocalRotateZ(endValueV3.z, duration),
                DOTweenAnimationType.Scale => transform.DOScale(optionalBool0 ? new Vector3(endValueFloat, endValueFloat, endValueFloat) : endValueV3, duration),
                DOTweenAnimationType.Color => target switch
                {
                    Graphic t => t.DOColor(endValueColor, duration),
                    SpriteRenderer t => t.DOColor(endValueColor, duration),
                    Renderer t => t.material.DOColor(endValueColor, duration),
                    _ => throw new ArgumentOutOfRangeException(nameof(target), target, null)
                },
                DOTweenAnimationType.Fade => target switch
                {
                    CanvasGroup t => t.DOFade(endValueFloat, duration),
                    Graphic t => t.DOFade(endValueFloat, duration),
                    SpriteRenderer t => t.DOFade(endValueFloat, duration),
                    Renderer t => t.material.DOFade(endValueFloat, duration),
                    _ => throw new ArgumentOutOfRangeException(nameof(target), target, null)
                },
                DOTweenAnimationType.PunchPosition => target switch
                {
                    RectTransform t => t.DOPunchAnchorPos(endValueV3, duration, optionalInt0, optionalFloat0),
                    Transform t => t.DOPunchPosition(endValueV3, duration, optionalInt0, optionalFloat0),
                    _ => throw new ArgumentOutOfRangeException(nameof(target), target, null)
                },
                DOTweenAnimationType.PunchScale => transform.DOPunchScale(endValueV3, duration, optionalInt0, optionalFloat0),
                DOTweenAnimationType.PunchRotation => transform.DOPunchRotation(endValueV3, duration, optionalInt0, optionalFloat0),
                DOTweenAnimationType.ShakePosition => target switch
                {
                    RectTransform t => t.DOShakeAnchorPos(duration, endValueV3, optionalInt0, optionalFloat0, optionalBool1),
                    Transform t => t.DOShakePosition(duration, endValueV3, optionalInt0, optionalFloat0, optionalBool1),
                    _ => throw new ArgumentOutOfRangeException(nameof(target), target, null)
                },
                DOTweenAnimationType.ShakeScale => transform.DOShakeScale(duration, endValueV3, optionalInt0, optionalFloat0, optionalBool1),
                DOTweenAnimationType.ShakeRotation => transform.DOShakeRotation(duration, endValueV3, optionalInt0, optionalFloat0, optionalBool1),
                DOTweenAnimationType.UIAnchors => DOTween.To(() => ((RectTransform) target).anchorMin, x => ((RectTransform) target).anchorMin = ((RectTransform) target).anchorMax = x, (Vector2) endValueV3, duration),
                _ => throw new ArgumentOutOfRangeException(nameof(animationType), animationType, null)
            };
        }

#if UNITY_EDITOR
        void ISelfValidator.Validate(SelfValidationResult result)
        {
            if (animationType is DOTweenAnimationType.None)
                result.AddError("AnimationType must be set to a valid value");

            if (animationType
                is DOTweenAnimationType.LocalMove
                or DOTweenAnimationType.PunchPosition
                or DOTweenAnimationType.ShakePosition)
            {
                if (optionalBool0)
                    result.AddError("Snapping is not supported anymore.");
            }

            if (animationType is DOTweenAnimationType.LocalRotateZ)
            {
                if (endValueV3.x != 0 || endValueV3.y != 0)
                    result.AddError("LocalRotateZ can only rotate on the Z axis");
                if (isRelative is false)
                    result.AddError("LocalRotateZ must be relative. Otherwise, it would result unexpected rotation.");
            }

            if (animationType
                is DOTweenAnimationType.PunchPosition
                or DOTweenAnimationType.PunchRotation
                or DOTweenAnimationType.PunchScale)
            {
                if (easeType is not Ease.OutQuad)
                    result.AddError("Punch must use OutQuad ease type.");
                if (isFrom)
                    result.AddError("Punch cannot be from.");
            }

            if (animationType
                is DOTweenAnimationType.ShakePosition
                or DOTweenAnimationType.ShakeRotation
                or DOTweenAnimationType.ShakeScale)
            {
                if (easeType is not Ease.Linear)
                    result.AddError("Shake must use Linear ease type.");
                if (isFrom)
                    result.AddError("Shake cannot be from.");
            }

            if (animationType
                is DOTweenAnimationType.Fade
                or DOTweenAnimationType.Color
                or DOTweenAnimationType.PunchPosition
                or DOTweenAnimationType.PunchRotation
                or DOTweenAnimationType.PunchScale
                or DOTweenAnimationType.ShakePosition
                or DOTweenAnimationType.ShakeRotation
                or DOTweenAnimationType.ShakeScale
                or DOTweenAnimationType.UIAnchors)
            {
                if (isRelative)
                    result.AddError(animationType + " cannot be relative.");
            }
        }
#endif
    }
}