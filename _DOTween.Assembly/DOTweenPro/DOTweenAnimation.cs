// Author: Daniele Giardini - http://www.demigiant.com
// Created: 2015/03/12 15:55

// ReSharper disable InconsistentNaming

using System;
using Sirenix.OdinInspector;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.UI;
using Object = UnityEngine.Object;

#pragma warning disable 1591
namespace DG.Tweening
{
    /// <summary>
    /// Attach this to a GameObject to create a tween
    /// </summary>
    [AddComponentMenu("DOTween/DOTween Animation")]
    public sealed class DOTweenAnimation : MonoBehaviour
#if UNITY_EDITOR
        , ISelfValidator
#endif
    {
        public enum AnimationType : byte
        {
            None,
            Move, LocalMove,
            Rotate, LocalRotate,
            Scale,
            Color, Fade,
            Unused_0,
            PunchPosition, PunchRotation, PunchScale,
            ShakePosition, ShakeRotation, ShakeScale,
            Unused_1, Unused_2, Unused_3, Unused_4, Unused_5, Unused_6,
            Unused_7,
            UIAnchors,
        }

        public enum TargetType : byte
        {
            Unset,

            Unused_0,
            CanvasGroup,
            Graphic,
            Unused_1,
            RectTransform,
            Renderer, SpriteRenderer,
            Unused_2, Unused_3,
            Unused_4,
            Transform,
        }

        #region EVENTS - EDITOR-ONLY

        /// <summary>Used internally by the editor</summary>
        public static event Action<DOTweenAnimation> OnReset;
        static void Dispatch_OnReset(DOTweenAnimation anim) { if (OnReset != null) OnReset(anim); }

        #endregion

        [NonSerialized]
        public Tweener tween;

        public float delay;
        public float duration = 1;
        public Ease easeType = Ease.OutQuad;
        public AnimationCurve easeCurve = new(new Keyframe(0, 0), new Keyframe(1, 1));
        public LoopType loopType = LoopType.Restart;
        public int loops = 1;
        public bool isRelative;
        public bool isFrom;
        public bool autoKill = true;
        public bool autoGenerate = true; // If TRUE automatically creates the tween at startup

        [Required, ChildGameObjectsOnly]
        public Component target;
        public AnimationType animationType;
        public TargetType targetType;
        public bool autoPlay = true;

        public float endValueFloat;
        public Vector3 endValueV3;
        public Color endValueColor = new Color(1, 1, 1, 1);

        public bool optionalBool0, optionalBool1;
        public float optionalFloat0;
        public int optionalInt0;
        public RotateMode optionalRotationMode = RotateMode.Fast;

        bool _tweenAutoGenerationCalled; // TRUE after the tweens have been autoGenerated

        #region Unity Methods

        void Awake()
        {
            if (!autoGenerate) return;

            if (animationType != AnimationType.Move) {
                // Don't create tweens if we're using a RectTransform as a Move target,
                // because that will work only inside Start
                CreateTween(false, autoPlay);
                _tweenAutoGenerationCalled = true;
            }
        }

        void Start()
        {
            if (_tweenAutoGenerationCalled || !autoGenerate) return;

            CreateTween(false, autoPlay);
            _tweenAutoGenerationCalled = true;
        }

        void Reset()
        {
            Dispatch_OnReset(this);
        }

        void OnDestroy()
        {
            if (tween != null)
            {
                if (tween.active)
                    tween.Kill();
                tween = null;
            }
        }

        // Used also by DOTweenAnimationInspector when applying runtime changes and restarting
        /// <summary>
        /// Creates the tween manually (called automatically if AutoGenerate is set in the Inspector)
        /// from its target's current value.
        /// </summary>
        /// <param name="regenerateIfExists">If TRUE and an existing tween was already created (and not killed), kills it and recreates it with the current
        /// parameters. Otherwise, if a tween already exists, does nothing.</param>
        /// <param name="andPlay">If TRUE also plays the tween, otherwise only creates it</param>
        public void CreateTween(bool regenerateIfExists = false, bool andPlay = true)
        {
            Assert.AreNotEqual(TargetType.Unset, targetType, "TargetType is Unset");
            Assert.AreNotEqual(AnimationType.None, animationType, "AnimationType is None");

            if (tween != null) {
                if (tween.active) {
                    if (regenerateIfExists) tween.Kill();
                    else return;
                }
                tween = null;
            }

            if (target == null) {
                Logger.Warning($"{gameObject.name} :: This DOTweenAnimation's target/GameObject is unset: the tween will not be created.", gameObject);
                return;
            }

            // Create tween.
            tween = CreateTween(
                target, transform, animationType, targetType, duration,
                endValueFloat, endValueV3, endValueColor,
                optionalBool0, optionalBool1, optionalFloat0, optionalInt0,
                optionalRotationMode);

            if (tween == null) return;

            // For AnimationType.Fade and AnimationType.Color, tween cannot not be relative.
            var relative = isRelative;
            if (animationType is AnimationType.Fade or AnimationType.Color)
                relative = false;

            // Set from or relative.
            if (isFrom) {
                tween.From(relative);
            } else {
                tween.SetRelative(relative);
            }

            // Set basic tween settings.
            tween.SetTarget(gameObject)
                .SetDelay(delay).SetLoops(loops, loopType).SetAutoKill(autoKill)
                .OnKill(()=> tween = null);

            // Set easeType.
            if (easeType == Ease.INTERNAL_Custom) tween.SetEase(easeCurve);
            else tween.SetEase(easeType);

            if (andPlay) tween.Play();
            else tween.Pause();
        }

        #endregion

        #region Public Methods

        #region Internal (also used by Inspector)

        // Editor preview system
        /// <summary>
        /// Previews the tween in the editor. Only for DOTween internal usage: don't use otherwise.
        /// </summary>
        public Tweener CreateEditorPreview()
        {
            if (Application.isPlaying) return null;

            // CHANGE: first param switched to TRUE otherwise changing an animation and replaying in editor would still play old one
            CreateTween(true, autoPlay);
            return tween;
        }

        #endregion

        #endregion

        static Tweener CreateTween(
            Object target, Transform transform,
            AnimationType animationType, TargetType targetType,
            float duration,
            float endValueFloat,
            Vector3 endValueV3,
            Color endValueColor,
            bool optionalBool0,
            bool optionalBool1,
            float optionalFloat0,
            int optionalInt0,
            RotateMode optionalRotationMode)
        {
            switch (animationType)
            {
                case AnimationType.None:
                    break;
                case AnimationType.Move:
                    switch (targetType)
                    {
                        case TargetType.Transform:
                            return ((Transform) target).DOMove(endValueV3, duration, optionalBool0);
                        case TargetType.RectTransform:
                            return ((RectTransform) target).DOAnchorPos3D(endValueV3, duration, optionalBool0);
                    }
                    break;
                case AnimationType.LocalMove:
                    return transform.DOLocalMove(endValueV3, duration, optionalBool0);
                case AnimationType.Rotate:
                    Assert.AreEqual(TargetType.Transform, targetType);
                    return transform.DORotate(endValueV3, duration, optionalRotationMode);
                case AnimationType.LocalRotate:
                    return transform.DOLocalRotate(endValueV3, duration, optionalRotationMode);
                case AnimationType.Scale:
                    return transform.DOScale(optionalBool0 ? new Vector3(endValueFloat, endValueFloat, endValueFloat) : endValueV3, duration);
                case AnimationType.Color:
                    switch (targetType)
                    {
                        case TargetType.Renderer:
                            return ((Renderer) target).material.DOColor(endValueColor, duration);
#if true // SPRITE_MARKER
                        case TargetType.SpriteRenderer:
                            return ((SpriteRenderer) target).DOColor(endValueColor, duration);
#endif
#if true // UI_MARKER
                        case TargetType.Graphic:
                            return ((Graphic) target).DOColor(endValueColor, duration);
#endif
                    }
                    break;
                case AnimationType.Fade:
                    switch (targetType)
                    {
                        case TargetType.Renderer:
                            return ((Renderer) target).material.DOFade(endValueFloat, duration);
#if true // SPRITE_MARKER
                        case TargetType.SpriteRenderer:
                            return ((SpriteRenderer) target).DOFade(endValueFloat, duration);
#endif
#if true // UI_MARKER
                        case TargetType.Graphic:
                            return ((Graphic) target).DOFade(endValueFloat, duration);
                        case TargetType.CanvasGroup:
                            return ((CanvasGroup) target).DOFade(endValueFloat, duration);
#endif
                    }
                    break;
                case AnimationType.PunchPosition:
                    switch (targetType)
                    {
                        case TargetType.Transform:
                            return ((Transform) target).DOPunchPosition(endValueV3, duration, optionalInt0, optionalFloat0, optionalBool0);
#if true // UI_MARKER
                        case TargetType.RectTransform:
                            return ((RectTransform) target).DOPunchAnchorPos(endValueV3, duration, optionalInt0, optionalFloat0, optionalBool0);
#endif
                    }
                    break;
                case AnimationType.PunchScale:
                    return transform.DOPunchScale(endValueV3, duration, optionalInt0, optionalFloat0);
                case AnimationType.PunchRotation:
                    return transform.DOPunchRotation(endValueV3, duration, optionalInt0, optionalFloat0);
                case AnimationType.ShakePosition:
                    switch (targetType)
                    {
                        case TargetType.Transform:
                            return ((Transform) target).DOShakePosition(duration, endValueV3, optionalInt0, optionalFloat0, optionalBool0, optionalBool1);
#if true // UI_MARKER
                        case TargetType.RectTransform:
                            return ((RectTransform) target).DOShakeAnchorPos(duration, endValueV3, optionalInt0, optionalFloat0, optionalBool0, optionalBool1);
#endif
                    }
                    break;
                case AnimationType.ShakeScale:
                    return transform.DOShakeScale(duration, endValueV3, optionalInt0, optionalFloat0, optionalBool1);
                case AnimationType.ShakeRotation:
                    return transform.DOShakeRotation(duration, endValueV3, optionalInt0, optionalFloat0, optionalBool1);
                case AnimationType.UIAnchors:
                    return DOTween.To(
                        () => ((RectTransform) target).anchorMin,
                        x => ((RectTransform) target).anchorMin = ((RectTransform) target).anchorMax = x,
                        (Vector2) endValueV3, duration);
            }

            Debug.LogError("[DOTweenAnimation] animationType not implemented: " + animationType);
            return null;
        }

#if UNITY_EDITOR
        void ISelfValidator.Validate(SelfValidationResult result)
        {
            if (targetType
                is TargetType.Unset
                or TargetType.Unused_0
                or TargetType.Unused_1
                or TargetType.Unused_2
                or TargetType.Unused_3
                or TargetType.Unused_4
               )
            {
                result.AddError("TargetType must be set to a valid value");
            }

            if (animationType
                is AnimationType.None
                or AnimationType.Unused_0
                or AnimationType.Unused_1
                or AnimationType.Unused_2
                or AnimationType.Unused_3
                or AnimationType.Unused_4
                or AnimationType.Unused_5
                or AnimationType.Unused_6
                or AnimationType.Unused_7
               )
            {
                result.AddError("AnimationType must be set to a valid value");
            }
        }
#endif
    }
}
